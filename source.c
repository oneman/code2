#include "header.h"

struct kms_driver;
struct kms_bo {
  struct kms_driver *kms;
  void *ptr;
  size_t size;
  size_t offset;
  size_t pitch;
  unsigned handle;
};

enum kms_attrib {
	KMS_TERMINATE_PROP_LIST,
#define KMS_TERMINATE_PROP_LIST KMS_TERMINATE_PROP_LIST
	KMS_BO_TYPE,
#define KMS_BO_TYPE KMS_BO_TYPE
	KMS_WIDTH,
#define KMS_WIDTH KMS_WIDTH
	KMS_HEIGHT,
#define KMS_HEIGHT KMS_HEIGHT
	KMS_PITCH,
#define KMS_PITCH KMS_PITCH
	KMS_HANDLE,
#define KMS_HANDLE KMS_HANDLE
};

enum kms_bo_type {
	KMS_BO_TYPE_SCANOUT_X8R8G8B8 = (1 << 0),
#define KMS_BO_TYPE_SCANOUT_X8R8G8B8 KMS_BO_TYPE_SCANOUT_X8R8G8B8
	KMS_BO_TYPE_CURSOR_64X64_A8R8G8B8 =  (1 << 1),
#define KMS_BO_TYPE_CURSOR_64X64_A8R8G8B8 KMS_BO_TYPE_CURSOR_64X64_A8R8G8B8
};

struct kms_driver {
  int (*get_prop)(struct kms_driver *kms, const unsigned key, unsigned *out);
  int (*destroy)(struct kms_driver *kms);
  int (*bo_create)(struct kms_driver *kms, unsigned width, unsigned height,
    enum kms_bo_type type, const unsigned *attr, struct kms_bo **out);
  int (*bo_get_prop)(struct kms_bo *bo, const unsigned key, unsigned *out);
  int (*bo_map)(struct kms_bo *bo, void **out);
  int (*bo_unmap)(struct kms_bo *bo);
  int (*bo_destroy)(struct kms_bo *bo);
  int fd;
};

int kms_create(int fd, struct kms_driver **out);
int kms_get_prop(struct kms_driver *kms, unsigned key, unsigned *out);
int kms_destroy(struct kms_driver **kms);
int kms_bo_create(struct kms_driver *kms, const unsigned *attr, struct kms_bo **out);
int kms_bo_get_prop(struct kms_bo *bo, unsigned key, unsigned *out);
int kms_bo_map(struct kms_bo *bo, void **out);
int kms_bo_unmap(struct kms_bo *bo);
int kms_bo_destroy(struct kms_bo **bo);


#ifndef LIBDRM_LIBDRM_H
#define LIBDRM_LIBDRM_H
#if HAVE_VISIBILITY
#  define drm_private __attribute__((visibility("hidden")))
#  define drm_public  __attribute__((visibility("default")))
#else
#  define drm_private
#  define drm_public
#endif

drm_private int linux_create(int fd, struct kms_driver **out);
drm_private int vmwgfx_create(int fd, struct kms_driver **out);
drm_private int intel_create(int fd, struct kms_driver **out);
drm_private int dumb_create(int fd, struct kms_driver **out);
drm_private int nouveau_create(int fd, struct kms_driver **out);
drm_private int radeon_create(int fd, struct kms_driver **out);
drm_private int exynos_create(int fd, struct kms_driver **out);

/**
 * Static (compile-time) assertion.
 * Basically, use COND to dimension an array.  If COND is false/zero the
 * array size will be -1 and we'll get a compilation error.
 */
#define STATIC_ASSERT(COND) \
   do { \
      (void) sizeof(char [1 - 2*!(COND)]); \
   } while (0)

#if defined(__BIONIC__) && !defined(__LP64__)

static inline void *drm_mmap(void *addr, size_t length, int prot, int flags,
                             int fd, loff_t offset)
{
   /* offset must be aligned to 4096 (not necessarily the page size) */
   if (offset & 4095) {
      errno = EINVAL;
      return MAP_FAILED;
   }
   return mmap64(addr, length, prot, flags, fd, offset);
}
#  define drm_munmap(addr, length) \
              munmap(addr, length)
#else
/* assume large file support exists */
#  define drm_mmap(addr, length, prot, flags, fd, offset) \
              mmap(addr, length, prot, flags, fd, offset)
static inline int drm_munmap(void *addr, size_t length)
{
   /* Copied from configure code generated by AC_SYS_LARGEFILE */
#define LARGE_OFF_T ((((off_t) 1 << 31) << 31) - 1 + \
                     (((off_t) 1 << 31) << 31))
   STATIC_ASSERT(LARGE_OFF_T % 2147483629 == 721 &&
                 LARGE_OFF_T % 2147483647 == 1);
#undef LARGE_OFF_T
   return munmap(addr, length);
}
#endif
#endif

#define PATH_SIZE 512
static int linux_name_from_sysfs(int fd, char **out) {
	char path[PATH_SIZE+1] = ""; /* initialize to please valgrind */
	char link[PATH_SIZE+1] = "";
	struct stat buffer;
	unsigned maj, min;
	char* slash_name;
	int ret;
	/* 
	 * Inside the sysfs directory for the device there is a symlink
	 * to the directory representing the driver module, that path
	 * happens to hold the name of the driver.
	 *
	 * So lets get the symlink for the drm device. Then read the link
	 * and filter out the last directory which happens to be the name
	 * of the driver, which we can use to load the correct interface.
	 *
	 * Thanks to Ray Strode of Plymouth for the code.
	 */
	ret = fstat(fd, &buffer);
	if (ret)
		return -EINVAL;
	if (!S_ISCHR(buffer.st_mode))
		return -EINVAL;
	maj = major(buffer.st_rdev);
	min = minor(buffer.st_rdev);
	snprintf(path, PATH_SIZE, "/sys/dev/char/%d:%d/device/driver", maj, min);
	printf("%s\n", path);
	if (readlink(path, link, PATH_SIZE) < 0)
		return -EINVAL;
	/* link looks something like this: ../../../bus/pci/drivers/intel */
	slash_name = strrchr(link, '/');
	if (!slash_name)
		return -EINVAL;
	/* copy name and at the same time remove the slash */
	*out = strdup(slash_name + 1);
  printf("%s\n", *out);
	return 0;
}

static int linux_from_sysfs(int fd, struct kms_driver **out) {
	char *name;
	int ret;
	ret = linux_name_from_sysfs(fd, &name);
	if (ret)
		return ret;
		ret = -ENOSYS;
	free(name);
	return ret;
}

drm_private int linux_create(int fd, struct kms_driver **out) {
	if (!dumb_create(fd, out))
		return 0;
	return linux_from_sysfs(fd, out);
}
  
drm_public int kms_create(int fd, struct kms_driver **out) {
	return linux_create(fd, out);
}

drm_public int kms_get_prop(struct kms_driver *kms, unsigned key,
 unsigned *out) {
	switch (key) {
	case KMS_BO_TYPE:
		break;
	default:
		return -EINVAL;
	}
	return kms->get_prop(kms, key, out);
}

drm_public int kms_destroy(struct kms_driver **kms) {
	if (!(*kms))
		return 0;
	free(*kms);
	*kms = NULL;
	return 0;
}

drm_public int kms_bo_create(struct kms_driver *kms, const unsigned *attr,
 struct kms_bo **out) {
	unsigned width = 0;
	unsigned height = 0;
	enum kms_bo_type type = KMS_BO_TYPE_SCANOUT_X8R8G8B8;
	int i;
	for (i = 0; attr[i];) {
		unsigned key = attr[i++];
		unsigned value = attr[i++];
		switch (key) {
		case KMS_WIDTH:
			width = value;
			break;
		case KMS_HEIGHT:
			height = value;
			break;
		case KMS_BO_TYPE:
			type = value;
			break;
		default:
			return -EINVAL;
		}
	}
	if (width == 0 || height == 0)
		return -EINVAL;
	/* XXX sanity check type */
	if (type == KMS_BO_TYPE_CURSOR_64X64_A8R8G8B8 &&
	    (width != 64 || height != 64))
		return -EINVAL;
	return kms->bo_create(kms, width, height, type, attr, out);
}

drm_public int kms_bo_get_prop(struct kms_bo *bo, unsigned key, unsigned *out) {
	switch (key) {
	case KMS_PITCH:
		*out = bo->pitch;
		break;
	case KMS_HANDLE:
		*out = bo->handle;
		break;
	default:
		return -EINVAL;
	}
	return 0;
}

drm_public int kms_bo_map(struct kms_bo *bo, void **out) {
	return bo->kms->bo_map(bo, out);
}

drm_public int kms_bo_unmap(struct kms_bo *bo) {
	return bo->kms->bo_unmap(bo);
}

drm_public int kms_bo_destroy(struct kms_bo **bo) {
	int ret;
	if (!(*bo))
		return 0;
	ret = (*bo)->kms->bo_destroy(*bo);
	if (ret)
		return ret;
	*bo = NULL;
	return 0;
}

drm_private int linux_create(int fd, struct kms_driver **out);
drm_private int vmwgfx_create(int fd, struct kms_driver **out);
drm_private int intel_create(int fd, struct kms_driver **out);
drm_private int dumb_create(int fd, struct kms_driver **out);
drm_private int nouveau_create(int fd, struct kms_driver **out);
drm_private int radeon_create(int fd, struct kms_driver **out);
drm_private int exynos_create(int fd, struct kms_driver **out);

struct dumb_bo {
	struct kms_bo base;
	unsigned map_count;
};

static int dumb_get_prop(struct kms_driver *kms, unsigned key, unsigned *out) {
  switch (key) {
	case KMS_BO_TYPE:
		*out = KMS_BO_TYPE_SCANOUT_X8R8G8B8 | KMS_BO_TYPE_CURSOR_64X64_A8R8G8B8;
		break;
	default:
		return -EINVAL;
	}
	return 0;
}

static int dumb_destroy(struct kms_driver *kms) {
	free(kms);
	return 0;
}

static int dumb_bo_create(struct kms_driver *kms, const unsigned width,
 const unsigned height, const enum kms_bo_type type, const unsigned *attr,
 struct kms_bo **out) {
	struct drm_mode_create_dumb arg;
	struct dumb_bo *bo;
	int i, ret;
	for (i = 0; attr[i]; i += 2) {
		switch (attr[i]) {
		case KMS_WIDTH:
		case KMS_HEIGHT:
			break;
		case KMS_BO_TYPE:
			break;
		default:
			return -EINVAL;
		}
	}
	bo = calloc(1, sizeof(*bo));
	if (!bo)
		return -ENOMEM;
	mset(&arg, 0, sizeof(arg));
	/* All BO_TYPE currently are 32bpp formats */
	arg.bpp = 32;
	arg.width = width;
	arg.height = height;
	ret = drmIoctl(kms->fd, DRM_IOCTL_MODE_CREATE_DUMB, &arg);
	if (ret)
		goto err_free;
	bo->base.kms = kms;
	bo->base.handle = arg.handle;
	bo->base.size = arg.size;
	bo->base.pitch = arg.pitch;
	*out = &bo->base;
	return 0;
err_free:
	free(bo);
	return ret;
}

static int dumb_bo_get_prop(struct kms_bo *bo, unsigned key, unsigned *out) {
	switch (key) {
	default:
		return -EINVAL;
	}
}

static int dumb_bo_map(struct kms_bo *_bo, void **out) {
	struct dumb_bo *bo = (struct dumb_bo *)_bo;
	struct drm_mode_map_dumb arg;
	void *map = NULL;
	int ret;
	if (bo->base.ptr) {
		bo->map_count++;
		*out = bo->base.ptr;
		return 0;
	}
	mset(&arg, 0, sizeof(arg));
	arg.handle = bo->base.handle;
	ret = drmIoctl(bo->base.kms->fd, DRM_IOCTL_MODE_MAP_DUMB, &arg);
	if (ret)
		return ret;
	map = drm_mmap(0, bo->base.size, PROT_READ | PROT_WRITE, MAP_SHARED, bo->base.kms->fd, arg.offset);
	if (map == MAP_FAILED)
		return -errno;
	bo->base.ptr = map;
	bo->map_count++;
	*out = bo->base.ptr;
	return 0;
}

static int dumb_bo_unmap(struct kms_bo *_bo) {
	struct dumb_bo *bo = (struct dumb_bo *)_bo;
	bo->map_count--;
  return 0;
}

static int dumb_bo_destroy(struct kms_bo *_bo) {
	struct dumb_bo *bo = (struct dumb_bo *)_bo;
	struct drm_mode_destroy_dumb arg;
	int ret;
	if (bo->base.ptr) {
		/* XXX Sanity check map_count */
		drm_munmap(bo->base.ptr, bo->base.size);
		bo->base.ptr = NULL;
	}
	mset(&arg, 0, sizeof(arg));
	arg.handle = bo->base.handle;
	ret = drmIoctl(bo->base.kms->fd, DRM_IOCTL_MODE_DESTROY_DUMB, &arg);
	if (ret)
		return -errno;
	free(bo);
	return 0;
}

drm_private int dumb_create(int fd, struct kms_driver **out) {
	struct kms_driver *kms;
	int ret;
	uint64_t cap = 0;
	ret = drmGetCap(fd, DRM_CAP_DUMB_BUFFER, &cap);
	if (ret || cap == 0)
		return -EINVAL;
	kms = calloc(1, sizeof(*kms));
	if (!kms)
		return -ENOMEM;
	kms->fd = fd;
	kms->bo_create = dumb_bo_create;
	kms->bo_map = dumb_bo_map;
	kms->bo_unmap = dumb_bo_unmap;
	kms->bo_get_prop = dumb_bo_get_prop;
	kms->bo_destroy = dumb_bo_destroy;
	kms->get_prop = dumb_get_prop;
	kms->destroy = dumb_destroy;
	*out = kms;
	return 0;
}

struct flip_context {
	int fb_id[2];
	int current_fb_id;
	int crtc_id;
	struct timeval start;
	int swap_count;
};

typedef void (*draw_func_t)(char *addr, int w, int h, int pitch);

void draw_buffer(char *addr, int w, int h, int pitch)
{
	int i, j;

	/* paint the buffer with colored tiles */
	for (j = 0; j < h; j++) {
		uint32_t *fb_ptr = (uint32_t*)((char*)addr + j * pitch);
		for (i = 0; i < w; i++) {
			div_t d = div(i, w);
			fb_ptr[i] =
				0x00130502 * (d.quot >> 6) +
				0x000a1120 * (d.rem >> 6);
		}
	}
}

void draw_buffer_with_cairo(char *addr, int w, int h, int pitch)
{
	cairo_t *cr;
	cairo_surface_t *surface;

	surface = cairo_image_surface_create_for_data(
		addr,
		CAIRO_FORMAT_ARGB32,
        w, h, pitch);
    cr = cairo_create(surface);
	cairo_surface_destroy(surface);

	/* Use normalized coordinates hereinafter */
	cairo_scale (cr, w, h);

	/* rectangle stroke */
	cairo_set_source_rgb (cr, 1, 1, 1);
	cairo_set_line_width (cr, 0.05);
	cairo_rectangle (cr, 0.1, 0.1, 0.3, 0.4);
	cairo_stroke (cr);

	/* circle fill */
	cairo_set_source_rgba(cr, 1, 0, 0, 0.5);
	cairo_arc(cr, 0.7, 0.3, 0.2, 0, 2 * M_PI);
	cairo_fill(cr);

	/* text */
	cairo_set_source_rgb (cr, 0.0, 0.0, 0.0);
	cairo_select_font_face (cr, "Georgia",
    	CAIRO_FONT_SLANT_NORMAL, CAIRO_FONT_WEIGHT_BOLD);
	cairo_set_font_size (cr, 0.1);
	cairo_move_to (cr, 0.1, 0.8);
	cairo_show_text (cr, "drawn with cairo");
	
	cairo_destroy(cr);
}

void create_bo(struct kms_driver *kms_driver, int w, int h, int *out_pitch,
  struct kms_bo **out_kms_bo, int *out_handle, draw_func_t draw) {
  void *map_buf;
  struct kms_bo *bo;
  int pitch, handle;
  unsigned bo_attribs[] = {
		KMS_WIDTH,   w,
		KMS_HEIGHT,  h,
		KMS_BO_TYPE, KMS_BO_TYPE_SCANOUT_X8R8G8B8,
		KMS_TERMINATE_PROP_LIST
  };
	int ret;

	/* ceate kms buffer object, opaque struct identied by struct kms_bo pointer */
	ret = kms_bo_create(kms_driver, bo_attribs, &bo);
	if(ret){
		fprintf(stderr, "kms_bo_create failed: %s\n", strerror(errno));
		goto exit;
	}

	/* get the "pitch" or "stride" of the bo */
	ret = kms_bo_get_prop(bo, KMS_PITCH, &pitch);
	if(ret){
		fprintf(stderr, "kms_bo_get_prop KMS_PITCH failed: %s\n", strerror(errno));
		goto free_bo;
	}

	/* get the handle of the bo */
	ret = kms_bo_get_prop(bo, KMS_HANDLE, &handle);
	if(ret){
		fprintf(stderr, "kms_bo_get_prop KMS_HANDL failed: %s\n", strerror(errno));
		goto free_bo;
	}

	/* map the bo to user space buffer */
	ret = kms_bo_map(bo, &map_buf);
	if(ret){
		fprintf(stderr, "kms_bo_map failed: %s\n", strerror(errno));
		goto free_bo;
	}

	draw(map_buf, w, h, pitch);

	kms_bo_unmap(bo);

	ret = 0;
	*out_kms_bo = bo;
	*out_pitch = pitch;
	*out_handle = handle;
	goto exit;

free_bo:
	kms_bo_destroy(&bo);
	
exit:
	return;

}

void page_flip_handler(int fd, unsigned int frame,
		  unsigned int sec, unsigned int usec, void *data)
{
	struct flip_context *context;
	unsigned int new_fb_id;
	struct timeval end;
	double t;

	context = data;
	if (context->current_fb_id == context->fb_id[0])
		new_fb_id = context->fb_id[1];
	else
		new_fb_id = context->fb_id[0];
			
	drmModePageFlip(fd, context->crtc_id, new_fb_id,
			DRM_MODE_PAGE_FLIP_EVENT, context);
	context->current_fb_id = new_fb_id;
	context->swap_count++;
	if (context->swap_count == 60) {
		gettimeofday(&end, NULL);
		t = end.tv_sec + end.tv_usec * 1e-6 -
			(context->start.tv_sec + context->start.tv_usec * 1e-6);
		fprintf(stderr, "freq: %.02fHz\n", context->swap_count / t);
		context->swap_count = 0;
		context->start = end;
	}
}

char *usbkeyboardlabeltable[] = {
	"", "", "", "",
	"aA", "bB", "cC", "dD", "eE", "fF", "gG", "hH", "iI", "jJ", "kK", "lL", "mM",
	"nN", "oO", "pP", "qQ", "rR", "sS", "tT", "uU", "vV", "wW", "xX", "yY", "zZ",
	"1!","2@","3#","4$","5%","6^","7&","8*","9(","0)",
	"Enter", "Escape", "Backspace", "Tab",
	" ",
	"-_", "=+", "[{", "]}",	"\\|", "", ";:", "'\"", "`~", ",<", ".>", "/?",
	"CapsLock",
	"F1","F2","F3","F4","F5","F6","F7","F8","F9","F10","F11","F12",
	"Print", "ScrollLock", "Pause",
	"Insert", "Home", "PageUp", "Delete", "End", "PageDown",
	"Right", "Left", "Down", "Up",
	"NumLock", "/", "*", "-", "+", "Enter",
	"1", "2", "3", "4", "5", "6", "7", "8", "9", "0",
	".", "", "Menu"
};

int textkey(char k) {
  if (!k) return 0;
  if (k > 3) {
    if (k < 40) return 1;
    if ((k > 44) && (k < 57)) return 1;
  }
  return 0; 
}

void printmod(char *k) {
  int p = 0;
  static char out[64];
  mset(out, 0, sizeof(out));
  if (k[1] != 0) {
    printf("keyboard scan error");
    exit(1);
  }
  if ((k[0] & 0b00000001) || (k[0] & 0b00010000)) {
    p += snprintf(out + p, sizeof(out) - p, "Control");
  }
  if ((k[0] & 0b00000010) || (k[0] & 0b00100000)) {
    p += snprintf(out + p, sizeof(out) - p, "Shift");
  }
  if ((k[0] & 0b00000100) || (k[0] & 0b01000000)) {
    p += snprintf(out + p, sizeof(out) - p, "Alt");
  }
  if ((k[0] & 0b00001000) || (k[0] & 0b10000000)) {
    p += snprintf(out + p, sizeof(out) - p, "Meta");
  }
  if (p) printf("%*s\n", p, out);
}

int controling(char k) {
  if ((k & 0b00000001) || (k & 0b00010000)) return 1;
  return 0;
}

int shifting(char k) {
  if ((k & 0b00000010) || (k & 0b00100000)) return 1;
  return 0;
}

int alting(char k) {
  if ((k & 0b00000100) || (k & 0b01000000)) return 1;
  return 0;
}

int metaing(char k) {
  if ((k & 0b00001000) || (k & 0b10000000)) return 1;
  return 0;
}

int scan_xdigit(char c) {
  if ((c == 'A') || (c == 'a')) return 0x0A;
  if ((c == 'B') || (c == 'b')) return 0x0B;
  if ((c == 'C') || (c == 'c')) return 0x0C;
  if ((c == 'D') || (c == 'd')) return 0x0D;
  if ((c == 'E') || (c == 'e')) return 0x0E;
  if ((c == 'F') || (c == 'f')) return 0x0F;
  if (c == '0') return 0x0;
  if (c == '1') return 0x01;
  if (c == '2') return 0x02;
  if (c == '3') return 0x03;
  if (c == '4') return 0x04;
  if (c == '5') return 0x05;
  if (c == '6') return 0x06;
  if (c == '7') return 0x07;
  if (c == '8') return 0x08;
  if (c == '9') return 0x09;
  perror("scan_xdigit");
  exit(1);
  return 0;
}

char scanx(char *src) {
  char b = scan_xdigit(src[0]) << 4;
  b += scan_xdigit(src[1]);
  return b;
}

void sprintx(char *dst, const char *src, int n)  {
  const char xx[]= "0123456789ABCDEF";
  for (; n > 0; --n) {
    unsigned char c = *src++;
    *dst++ = xx[c >> 4];
    *dst++ = xx[c & 0x0f];
  }
}

void kbye(void) {
  write(1, "0k\n", 3);
  exit(0);
}

int EFAIL(char *msg) {
  perror(msg);
  write(1, "\nFAIL\n", 6);
  write(1, msg, strlen(msg));
  write(1, "\n", 1);
  return 1;
}

int main(int argc, char *argv[]) {
  int R = setuid(0);
  if (R) EFAIL("1.0 setuid run with sudo");
  R = setgid(0);
  if (R) EFAIL("1.5 setgid run with sudo");
  R = setvbuf(stdin, NULL, _IONBF, 0);
  if (R) EFAIL("2 setvbuf stdin _IONBF");
  R = setvbuf(stdout, NULL, _IONBF, 0);
  if (R) EFAIL("3 setvbuf stdout _IONBF");
  R = setvbuf(stderr, NULL, _IONBF, 0);
  if (R) EFAIL("4 setvbuf stderr _IONBF");
  sigset_t mask;
  sigemptyset(&mask);
  sigfillset(&mask);
  R = sigprocmask(SIG_BLOCK, &mask, NULL);
  if (R) EFAIL("5 sigprocmask");
  int SFD = signalfd(-1, &mask, SFD_NONBLOCK | SFD_CLOEXEC);
  int MD = memfd_create("pixmap-framebuffer", MFD_CLOEXEC);
  int PD = epoll_create1(EPOLL_CLOEXEC);
  int ED = eventfd(2601, EFD_NONBLOCK | EFD_CLOEXEC);
  int TD = timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK | TFD_CLOEXEC);
  int SD = socket(AF_PACKET,
                  SOCK_RAW | SOCK_NONBLOCK | SOCK_CLOEXEC, htons(ETH_P_ALL));
  int ID = inotify_init1(IN_NONBLOCK | IN_CLOEXEC);
  if ((6*6+6) != (SFD + MD + PD + ED + TD + SD + ID)) EFAIL("6*6+6=42 PANICAN");
  int WD = inotify_add_watch(ID, "/dev", IN_CREATE);
  if (WD == -1) EFAIL("6 inotify_add_watch /dev IN_CREATE");
  for (int fu = 1;; fu++) {
    if (fu > 1) printf("ftruncate fu %d!\n", fu);
    R = ftruncate(MD, 4205260800);
    if (R == 0) break;
    if (R == -1) {
      if ((errno == EINTR) && (fu < 26)) {
        usleep(fu * 260);
        continue;
      }
      EFAIL("7 ftruncate 4205260800");
    }
  }
  char *DAT = mmap(NULL, 4205260800, PROT_READ | PROT_WRITE, MAP_SHARED, MD, 0);
	if (!DAT) EFAIL("7 mmap 4205260800");
  printf("Everything worked? Lets touch mem\n");
  mset(DAT, 'K', 4205260800);
  printf("we touched all the memory!\n");
  for (int fu = 1;; fu++) {
    if (fu > 1) printf("mlock fu %d!\n", fu);
    R = mlock(DAT, 4205260800);
    if (R == 0) break;
    if (R == -1) {
      if ((errno == EAGAIN) && (fu < 26)) {
        usleep(fu * 260);
        continue;
      }
      EFAIL("8 mlock 4205260800");
    }
  }

  printf("Cairo %s\n", cairo_version_string());

  pw_init(&argc, &argv);
  char *pw_hdr_ver = pw_get_headers_version();
  const char *pw_lib_ver = pw_get_library_version();
  if (strsz(pw_hdr_ver) != strsz(pw_lib_ver)) return 42;
  if (mcmp(pw_hdr_ver, pw_lib_ver, strsz(pw_lib_ver))) return 666;
  printf("Pipewire %s\n", pw_hdr_ver);

  printf("GMP %s\n", gmp_version);
  mpz_t a, b, c, d, r, x;
  mpz_init_set_ui(b, 0);
  mpz_init_set_ui(c, 0);
  mpz_init_set_ui(r, 0);
  mpz_init_set_str(a, "4205260800", 10);
  mpz_init_set_str(d, "4205260799", 10);
  mpz_init_set_str(x, "18446744073709551616", 10);
  mpz_mod(r, d, x);
  gmp_printf("%Zd\n", r);
  mpz_t e;
  mpz_init(e);
  mpz_fac_ui(e, 26);
  gmp_printf("26!\n%Zd\n", e);
  mpz_t f;
  mpz_init(f);
  mpz_fac_ui(f, 126);
  gmp_printf("126!\n%Zd\n", f);
  mpz_t g;
  mpz_init(g);
  mpz_fac_ui(g, 209);
  gmp_printf("209!\n%Zd\n", g);
  mpz_clear(a);
  mpz_clear(b);
  mpz_clear(c);
  mpz_clear(d);
  mpz_clear(r);
  mpz_clear(x);
  mpz_clear(e);
  mpz_clear(f);
  mpz_clear(g);
  int HiD[26];
  char HiD_type[26];
  for (int i = 0; i < 26; i++) {
    HiD[i] = 0;
    HiD_type[i] = 0;
  }
  for (int i = 0; i < 26; i++) {
    struct hidraw_report_descriptor rpt;
    mset(&rpt, 0, sizeof(rpt));
    char devname[16];
    snprintf(devname, 16, "/dev/hidraw%d", i);
    R = open(devname, O_RDONLY | O_NONBLOCK);
    if (R < 0) continue;
    HiD[i] = R;
    R = ioctl(HiD[i], HIDIOCGRDESCSIZE, &rpt.size);
    if ((R < 0) || (rpt.size < 4)) EFAIL("HIDIOCGRDESCSIZE");
    R = ioctl(HiD[i], HIDIOCGRDESC, &rpt);
    if (R < 0) EFAIL("HIDIOCGRDESC");
    unsigned char *s = rpt.value;
    if ((s[0] != 5) || (s[1] != 1) || (s[2] != 9)) continue;
    if ((s[3] != 2) && (s[3] != 6)) continue;
    if (s[3] == 2) HiD_type[i] = 'm';
    if (s[3] == 6) HiD_type[i] = 'k';
  }
  for (int i = 0; i < 26; i++) {
    if (HiD[i] > 0) {
      if (HiD_type[i] == 'k') printf("keyboard on %d (fd %d)\n", i, HiD[i]);
      if (HiD_type[i] == 'm') printf("mouse on %d (fd %d)\n", i, HiD[i]);
      if (HiD_type[i] == 0) {
        R = close(HiD[i]);
        if (R == -1) { perror("close"); }
        printf("something else was on %d (fd %d)\n", i, HiD[i]);
        HiD[i] = 0;
      }
    }
  }
  for (int i = 0; i < 676; i++) {
	  /* continue; */
	  char c1 = 96 + 1 + (i / 26);
	  char c2 = 96 + 1 + (i % 26);
	  char filename[256];
	  char *map_dir = getenv("OVERRIDE_PROGRAM_PIXMAP_BASEDIR");
	  if (map_dir) printf("using %s for dat pix map\n", map_dir);
	  if (!map_dir) map_dir = "/map";
	  snprintf(filename, 256, "%s/%c/%c/%s%s.png", map_dir, c1, c2,
	   nato[c1 - 97], nato[c2 - 97]);
	  printf("Loading %3d %s\n", i, filename);
	  cairo_surface_t *cst = cairo_image_surface_create_from_png(filename);
	  cairo_status_t cairo_errno = cairo_surface_status(cst);
	  if (cairo_errno) {
      printf("PC_LOAD_LETTER %s\n", cairo_status_to_string(cairo_errno));
      continue;
	  }
	  if (cairo_image_surface_get_width(cst) != 1920) {
	    exit(1);
	  }
    if (cairo_image_surface_get_height(cst) != 1080) exit(1);
    if (cairo_image_surface_get_stride(cst) != 1920 * 4) exit(1);
    if (cairo_image_surface_get_format(cst) != CAIRO_FORMAT_RGB24) {
      printf("not rite bro\n"); exit(1);
    }
    unsigned char *dat = cairo_image_surface_get_data(cst);
    unsigned long x0 = (i % 26) * (1920*3);
    int stride = 1920 * 26 * 3;
    for (int yy = 0; yy < 1080; yy++) {
      int pyy = yy * stride;
      for (int xx = 0; xx < 1920; xx++) {
        int pxy = pyy + (xx * 3);
        DAT[pxy] = dat[(yy * 4) + (xx * 4)];
        DAT[pxy + 1] = dat[(yy * 4) + (xx * 4) + 1];
        DAT[pxy + 2] = dat[(yy * 4) + (xx * 4) + 2];
        //DAT[(x0*y0) + pxy + (xx * 3) + 1] = dat[px * 4 + 1];
        //DAT[(x0*y0) + pxy + (xx * 3) + 2] = dat[px * 4 + 2];
      }
    }
    cairo_surface_destroy(cst);
  }
  kbye();
  int fd, pitch, bo_handle, fb_id, second_fb_id;
	drmModeRes *resources;
	drmModeConnector *connector;
	drmModeEncoder *encoder;
	drmModeModeInfo mode;
	drmModeCrtcPtr orig_crtc;
	struct kms_driver *kms_driver;
	struct kms_bo *kms_bo, *second_kms_bo;
	void *map_buf;
	int ret, i;
  int DFD = open("/dev/dri/card0", O_RDWR);
	if (DFD < 0){
		fprintf(stderr, "drmOpen failed: %s\n", strerror(errno));
		exit(1);
	}
	resources = drmModeGetResources(DFD);
	if (resources == NULL){
		fprintf(stderr, "drmModeGetResources failed: %s\n", strerror(errno));
		goto close_fd;
	}
	/* find the first available connector with modes */
	for (i=0; i < resources->count_connectors; ++i){
		connector = drmModeGetConnector(DFD, resources->connectors[i]);
		if(connector != NULL){
			fprintf(stderr, "connector %d found\n", connector->connector_id);
			if(connector->connection == DRM_MODE_CONNECTED
				&& connector->count_modes > 0)
				break;
			drmModeFreeConnector(connector);
		}
		else
			fprintf(stderr, "get a null connector pointer\n");
	}
	if(i == resources->count_connectors){
		fprintf(stderr, "No active connector found.\n");
		goto free_drm_res;
	}

	mode = connector->modes[0];
	fprintf(stderr, "(%dx%d)\n", mode.hdisplay, mode.vdisplay);

	/* find the encoder matching the first available connector */
  for (i = 0; i < resources->count_encoders; ++i) {
    encoder = drmModeGetEncoder(DFD, resources->encoders[i]);
    if(encoder != NULL) {
      fprintf(stderr, "encoder %d found\n", encoder->encoder_id);
			if (encoder->encoder_id == connector->encoder_id) break;
			drmModeFreeEncoder(encoder);
		} else {
		  fprintf(stderr, "get a null encoder pointer\n");
		}
	}
	if (i == resources->count_encoders) {
		fprintf(stderr, "No matching encoder with connector, shouldn't happen\n");
		goto free_drm_res;
	}

	/* init kms bo stuff */	
	ret = kms_create(DFD, &kms_driver);
	if(ret){
		fprintf(stderr, "kms_create failed: %s\n", strerror(errno));
		goto free_drm_res;
	}

	create_bo(kms_driver, mode.hdisplay, mode.vdisplay, 
		&pitch, &kms_bo, &bo_handle, draw_buffer);

	/* add FB which is associated with bo */
	ret = drmModeAddFB(DFD, mode.hdisplay, mode.vdisplay, 24, 32, pitch, bo_handle, &fb_id);
	if(ret){
		fprintf(stderr, "drmModeAddFB failed (%ux%u): %s\n",
			mode.hdisplay, mode.vdisplay, strerror(errno));
		goto free_first_bo;
	}

	orig_crtc = drmModeGetCrtc(DFD, encoder->crtc_id);
	if (orig_crtc == NULL)
	  goto free_first_bo;

	/* kernel mode setting, wow! */
	ret = drmModeSetCrtc(
				DFD, encoder->crtc_id, fb_id, 
				0, 0, 	/* x, y */ 
				&connector->connector_id, 
				1, 		/* element count of the connectors array above*/
				&mode);
	if(ret){
		fprintf(stderr, "drmModeSetCrtc failed: %s\n", strerror(errno));
		goto free_first_fb;
	}

	create_bo(kms_driver, mode.hdisplay, mode.vdisplay, 
		&pitch, &second_kms_bo, &bo_handle, draw_buffer);

	/* add another FB which is associated with bo */
	ret = drmModeAddFB(DFD, mode.hdisplay, mode.vdisplay, 24, 32, pitch, bo_handle, &second_fb_id);
	if(ret){
		fprintf(stderr, "drmModeAddFB failed (%ux%u): %s\n",
			mode.hdisplay, mode.vdisplay, strerror(errno));
		goto free_second_bo;
	}
	
	struct flip_context flip_context;
	mset(&flip_context, 0, sizeof flip_context);

	ret = drmModePageFlip(
		DFD, encoder->crtc_id, second_fb_id,
		DRM_MODE_PAGE_FLIP_EVENT, &flip_context);
	if (ret) {
		fprintf(stderr, "failed to page flip: %s\n", strerror(errno));
		goto free_second_fb;
	}

	flip_context.fb_id[0] = fb_id;
	flip_context.fb_id[1] = second_fb_id;
	flip_context.current_fb_id = second_fb_id;
	flip_context.crtc_id = encoder->crtc_id;
	flip_context.swap_count = 0;
	gettimeofday(&flip_context.start, NULL);

	/* disable stdin buffered i/o and local echo */
	struct termios old_tio, new_tio;
	tcgetattr(STDIN_FILENO, &old_tio);
	new_tio = old_tio;
	new_tio.c_lflag &= (~ICANON & ~ECHO);
	tcsetattr(STDIN_FILENO, TCSANOW, &new_tio);

	drmEventContext evctx;
	mset(&evctx, 0, sizeof evctx);
	evctx.version = DRM_EVENT_CONTEXT_VERSION;
	evctx.vblank_handler = NULL;
	evctx.page_flip_handler = page_flip_handler;

  struct epoll_event ev;
  ev.events = EPOLLIN;
  ev.data.fd = DFD;
  R = epoll_ctl(PD, EPOLL_CTL_ADD, ev.data.fd, &ev);
  if (R) { printf("epoll_ctlfail: %s\n", strerror(errno)); exit(1); }
  ev.data.fd = SFD;
  R = epoll_ctl(PD, EPOLL_CTL_ADD, ev.data.fd, &ev);
  if (R) { printf("epoll_ctlfail: %s\n", strerror(errno)); exit(1); }

  for (;;) {
    ret = epoll_wait(PD, &ev, 1, 1000);
    if (ret == -1) { printf("epoll_waitfail: %s\n", strerror(errno)); exit(1); }
    if (ret == 0) { printf("epoll_wait, long time, 1000ms!\n"); continue; }
    if (ev.events & EPOLLIN) {
      if (ev.data.fd == DFD) { ret = drmHandleEvent(fd, &evctx); continue; }
      if (ev.data.fd == SFD) { break; }
    }
  }
  ret = drmModeSetCrtc(fd, orig_crtc->crtc_id, orig_crtc->buffer_id,
   orig_crtc->x, orig_crtc->y, &connector->connector_id, 1, &orig_crtc->mode);
  if (ret) {
	  fprintf(stderr, "drmModeSetCrtc() restore original crtc failed: %m\n");
  }

	/* restore the old terminal settings */
	tcsetattr(STDIN_FILENO, TCSANOW, &old_tio);


free_second_fb:
	drmModeRmFB(fd, second_fb_id);
	
free_second_bo:
	kms_bo_destroy(&second_kms_bo);
	
free_first_fb:
	drmModeRmFB(fd, fb_id);
	
free_first_bo:
	kms_bo_destroy(&kms_bo);

free_kms_driver:
	kms_destroy(&kms_driver);
	
free_drm_res:
	drmModeFreeResources(resources);

close_fd:
	drmClose(fd);

  return 0;
}
